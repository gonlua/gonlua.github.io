<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gonlua.github.io</id>
    <title>gonlua&apos;s blog</title>
    <updated>2020-09-29T08:31:43.190Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gonlua.github.io"/>
    <link rel="self" href="https://gonlua.github.io/atom.xml"/>
    <subtitle>ゴンルアのブログ</subtitle>
    <logo>https://gonlua.github.io/images/avatar.png</logo>
    <icon>https://gonlua.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, gonlua&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Jetson Nano视频采集的一些知识]]></title>
        <id>https://gonlua.github.io/post/jetson-nano-shi-pin-cai-ji-de-yi-xie-zhi-shi/</id>
        <link href="https://gonlua.github.io/post/jetson-nano-shi-pin-cai-ji-de-yi-xie-zhi-shi/">
        </link>
        <updated>2020-09-24T05:22:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="uvc和v4l2的关系">UVC和V4L2的关系</h2>
<ul>
<li>UVC(USB Video Class)是一种usb视频设备驱动。用来支持usb视频设备，凡是usb接口的摄像头都能够支持</li>
<li>V4L2 (VIdeo4Linux2)是Linux下的视频采集框架。用来统一接口，向应用层提供API.</li>
<li>简单的讲V4L2就是用来管理UVC设备的并且能够提供视频相关的一些API。</li>
</ul>
<h3 id="查找是否有视频类借口信息">查找是否有视频类借口信息</h3>
<p><code>lsusb -d VID：PID -v | grep &quot;14 Video&quot;</code><br>
如果兼容UVC，则会输出类似信息<br>
bFunctionClass 14 Video<br>
bInterfaceClass 14 Video<br>
如果没有以上信息，则是non-UVC设备。</p>
<h3 id="查看usb视频设备信息的命令查看支持的图像格式">查看usb视频设备信息的命令(查看支持的图像格式)：</h3>
<pre><code>sudo apt-get install v4l-utils
v4l2-ctl --list-formats-ext -d /dev/video0
</code></pre>
<p>目前很多免驱的VGA2USB视频采集卡都是将利用了UVC，达到免驱的效果。</p>
<p>从Jetson Nano的软件技术文档可以得知其支持UVC:<br>
<img src="https://gonlua.github.io/post-images/1600925368069.png" alt="" loading="lazy"></p>
<p>因为Jetson Nano可以直接读取采集卡图像/视频<br>
打开设备：<br>
<code>./video-viewer.py v4l2:///dev/video0</code><br>
获取一帧图像并识别：<br>
<code>./imagenet.py /dev/video0</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux使用sed命令批量添加注释]]></title>
        <id>https://gonlua.github.io/post/linux-shi-yong-sed-ming-ling-pi-liang-tian-jia-zhu-shi/</id>
        <link href="https://gonlua.github.io/post/linux-shi-yong-sed-ming-ling-pi-liang-tian-jia-zhu-shi/">
        </link>
        <updated>2020-09-21T08:26:00.000Z</updated>
        <content type="html"><![CDATA[<p>有一批配置文件，里面都有一行配置如下：<br>
System1:<br>
<code>System1.Pool.Filters=stat</code></p>
<p>System2:<br>
<code>System2.Pool.Filters=stat</code></p>
<p>.......</p>
<p>现在想要批量给这一行配置添加注释（前面添加#号）<br>
可以使用sed命令：<br>
<code>sed -i 's/.*Pool.Filters=stat$/#&amp;/' ./*</code><br>
-i 表示修改文件（默认是输出到终端，不修改文件）<br>
s 表示替换字符串<br>
.*Pool.Filters=stat$ 表示原字符串, .<em>是通配符，$表示结尾<br>
#&amp; 表示替换字符串，&amp;引用原字符串<br>
./</em> 表示在当前文件夹所有文件中替换</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux 查看内存使用]]></title>
        <id>https://gonlua.github.io/post/linux-top-ming-ling-zhong-de-ge-xiang-nei-cun-shu-ju-yi-yi/</id>
        <link href="https://gonlua.github.io/post/linux-top-ming-ling-zhong-de-ge-xiang-nei-cun-shu-ju-yi-yi/">
        </link>
        <updated>2020-09-21T03:32:40.000Z</updated>
        <content type="html"><![CDATA[<p>使用top命令，按M按内存占用排序，内存相关列的意义如下：<br>
VIRT: 程序申请的内存，不管真的用了没有。<br>
RES: 真实使用了的内存，和%MEM对应。<br>
SHR: 共享内存<br>
DATA：数据占用的内存 (按f显示)<br>
<img src="https://gonlua.github.io/post-images/1600660201087.png" alt="" loading="lazy"></p>
<p>使用free命令可以看到总的内存使用情况 （-m -g 切换单位）<br>
<img src="https://gonlua.github.io/post-images/1600664902335.png" alt="" loading="lazy"></p>
<p>可以看到top里的%MEM加起来大概只有30%，为什么free里已用内存达到了7471？<br>
这是因为linux内核会消耗尽量多的内存来提供缓存，我们应该看第二行(-/+ buffers/cache)的值，才是真正的程序已使用内存。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Java VisualVM远程监控JAVA程序]]></title>
        <id>https://gonlua.github.io/post/li-yong-java-visualvm-yuan-cheng-jian-kong-java-cheng-xu/</id>
        <link href="https://gonlua.github.io/post/li-yong-java-visualvm-yuan-cheng-jian-kong-java-cheng-xu/">
        </link>
        <updated>2020-09-21T02:13:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="服务器端">服务器端</h2>
<h3 id="想要监控服务器端的程序需要先在服务器端允许jstatd">想要监控服务器端的程序，需要先在服务器端允许jstatd:</h3>
<ol>
<li>在服务器JDK的bin目录下创建文件jstatd.all.policy, 添加内容：</li>
</ol>
<pre><code class="language-json">grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {
    permission java.security.AllPermission;
};
</code></pre>
<ol start="2">
<li>运行命令<br>
<code>jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=192.168.XX.X -J-Djava.rmi.server.logCalls=true</code></li>
</ol>
<h2 id="客户端">客户端</h2>
<ol>
<li>在自己电脑，进入JDK的bin目录（最后JDK大版本和服务器的一致，不然有些监控看不到）</li>
<li>运行jvisualvm.exe</li>
<li>在左边的Remote右击添加远程服务器：<br>
<img src="https://gonlua.github.io/post-images/1600655034024.png" alt="" loading="lazy"><br>
就可以看到服务器上的Java程序，进行监控了。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM调整内存大小]]></title>
        <id>https://gonlua.github.io/post/jvm-diao-zheng-nei-cun-da-xiao/</id>
        <link href="https://gonlua.github.io/post/jvm-diao-zheng-nei-cun-da-xiao/">
        </link>
        <updated>2020-09-21T02:03:51.000Z</updated>
        <content type="html"><![CDATA[<p>在catalina.sh里添加：<br>
<code>JAVA_OPTS='-Xms512m -Xmx512m -XX:PermSize=512m -XX:MaxPermSize=512m'</code></p>
<p>其中：<br>
Xms: 最小堆大小<br>
Xmx: 最大堆大小<br>
XX:PermSize: 永久代初始值 (默认为物理内存的1/64)<br>
XX:MaxPermSize: 永久代最大值 (默认为物理内存的1/4)</p>
<p>JVM内存区域分为三种</p>
<ol>
<li>新生代：主要用来存放新生的对象，会频繁触发MinorGC。</li>
<li>老年代：主要存放应用中生命周期长的内存对象。没那么频繁地触发MajorGC。</li>
<li>永久代：永久保存区域，主要存放Class和Meta信息，难以被回收。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android模拟器修改host]]></title>
        <id>https://gonlua.github.io/post/android-mo-ni-qi-xiu-gai-host/</id>
        <link href="https://gonlua.github.io/post/android-mo-ni-qi-xiu-gai-host/">
        </link>
        <updated>2020-07-17T01:27:36.000Z</updated>
        <content type="html"><![CDATA[<p>执行以下命令：</p>
<ul>
<li>root获取root权限
<ul>
<li>adb root</li>
</ul>
</li>
<li>重新挂载
<ul>
<li>adb remount</li>
</ul>
</li>
<li>把hosts文件拉出来
<ul>
<li>adb pull /system/etc/hosts hosts</li>
</ul>
</li>
<li>修改hosts文件</li>
<li>把hosts文件push回去
<ul>
<li>adb push hosts /system/etc/hosts</li>
</ul>
</li>
</ul>
<p>我到了这一步提示(Android版本是7.1.1)<br>
<code>adb: error: failed to copy 'hosts' to '/system/etc/hosts': couldn't create file: Read-only file system</code></p>
<p>解决方法(我的adb版本：1.0.36)：</p>
<ul>
<li>adb push hosts /system/etc/hosts</li>
<li>adb root</li>
<li>adb shell</li>
<li>mount</li>
<li>exit</li>
<li>adb disable-verity</li>
<li>adb reboot</li>
<li>adb root</li>
<li>adb remount</li>
</ul>
<p>现在就可以进行写操作了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[create-react-app 阻止build打包service-worker]]></title>
        <id>https://gonlua.github.io/post/create-react-app-zu-zhi-build-da-bao-service-worker/</id>
        <link href="https://gonlua.github.io/post/create-react-app-zu-zhi-build-da-bao-service-worker/">
        </link>
        <updated>2020-07-13T02:55:42.000Z</updated>
        <content type="html"><![CDATA[<p>即使没有使用service-worker，build时仍然会将其打包。<br>
如果不想打包，可以去webpack.config.js里注释掉相关代码。<br>
位置：node_modules\react-scripts\config\webpack.config.js</p>
<p>将这一段注释掉：</p>
<pre><code class="language-js">isEnvProduction &amp;&amp;
    new WorkboxWebpackPlugin.GenerateSW({
        clientsClaim: true,
        exclude: [/\.map$/, /asset-manifest\.json$/],
        importWorkboxFrom: 'cdn',
        navigateFallback: paths.publicUrlOrPath + 'index.html',
        navigateFallbackBlacklist: [
        // Exclude URLs starting with /_, as they're likely an API call
        new RegExp('^/_'),
        // Exclude any URLs whose last part seems to be a file extension
        // as they're likely a resource and not a SPA route.
        // URLs containing a &quot;?&quot; character won't be blacklisted as they're likely
        // a route with query params (e.g. auth callbacks).
        new RegExp('/[^/?]+\\.[^/]+$'),
        ],
    }),
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Content Security Policy]]></title>
        <id>https://gonlua.github.io/post/content-security-policy/</id>
        <link href="https://gonlua.github.io/post/content-security-policy/">
        </link>
        <updated>2020-07-13T01:30:36.000Z</updated>
        <content type="html"><![CDATA[<p>“网页安全政策”CSP可以有效防止XSS(Cross Site Scriping)攻击。<br>
内网的网站可以利用它防止某些插件链接到外部。</p>
<p>使用方法很简单，在html加入meta标签，例子：<br>
<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org;&quot;&gt;</code></p>
<p>可以限制的资源类型：</p>
<ul>
<li>script-src：外部脚本</li>
<li>style-src：样式表</li>
<li>img-src：图像</li>
<li>media-src：媒体文件（音频和视频）</li>
<li>font-src：字体文件</li>
<li>object-src：插件（比如 Flash）</li>
<li>child-src：框架</li>
<li>frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</li>
<li>connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li>
<li>worker-src：worker脚本</li>
<li>manifest-src：manifest 文件<br>
<br/></li>
<li>default-src： 默认规则</li>
<li>'unsafe-inline': 允许执行页面内嵌的标签和事件监听函数</li>
</ul>
<p>规则默认只对ftp和https(s)有效，如果要允许Websocket，要加入&quot;ws:&quot;<br>
<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self' data: gap: ws: ssl.gstatic.com 'unsafe-inline';&quot;&gt;</code><br>
<br/><br>
兼容性：<br>
<img src="https://gonlua.github.io/post-images/1594606274392.png" alt="" loading="lazy"></p>
<p>参考文章：<br>
<a href="https://content-security-policy.com/">Content Security Policy Reference</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot用Actuator的shutdown不能关闭进程的解决方法]]></title>
        <id>https://gonlua.github.io/post/springboot-yong-actuator-de-shutdown-ming-ling-bu-neng-guan-bi-jin-cheng-jie-jue/</id>
        <link href="https://gonlua.github.io/post/springboot-yong-actuator-de-shutdown-ming-ling-bu-neng-guan-bi-jin-cheng-jie-jue/">
        </link>
        <updated>2020-07-10T09:45:34.000Z</updated>
        <content type="html"><![CDATA[<p>如果使用了scheduler（我用的是quartz），会阻止进程关闭。</p>
<p>解决方法是在Bean销毁前停掉scheduler:</p>
<pre><code class="language-java">@PreDestroy
public void preDestroy() {
    if (scheduler!=null) {
        try {
            scheduler.shutdown();
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React打包war]]></title>
        <id>https://gonlua.github.io/post/react-da-bao-war/</id>
        <link href="https://gonlua.github.io/post/react-da-bao-war/">
        </link>
        <updated>2020-07-10T00:09:54.000Z</updated>
        <content type="html"><![CDATA[<p>参考文章：<br>
<a href="https://www.megadix.it/blog/create-react-app-servlet/">Deploy React Applications in a Servlet Environment</a></p>
]]></content>
    </entry>
</feed>